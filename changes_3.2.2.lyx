#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass extarticle
\begin_preamble
\usepackage{minted}
\definecolor{bg}{rgb}{0.95,0.95,0.95}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family rmdefault
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 11
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 0
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 1cm
\topmargin 1cm
\rightmargin 1cm
\bottommargin 1cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Section
Changes introduced in HDF5_Parallel Branch
\end_layout

\begin_layout Standard
Items listed in blue effect compatibility of older code when using 3.2.2.
 Known problems are highlighted in red.
 The branch 
\end_layout

\begin_layout Subsection
General behavior changes and new recommendations for parallel performance
\end_layout

\begin_layout Itemize
The flush functions should not be used.
 Staggering the writing and reading by writing the data immediately avoids
 IO contention occurring when flush is being used.
\end_layout

\begin_layout Itemize
The parallel routines are meant for parallel file systems (GPFS or Lustre).
\end_layout

\begin_layout Itemize

\color blue
The default parallel input/output mode was changed from CGP_INDEPENDENT
 to CGP_COLLECTIVE.
\end_layout

\begin_layout Itemize

\color blue
An extra argument for passing MPI info to the CGNS library was added to
 cgp_pio_mode.
 
\color white
The extra argument should be used for MPI IO tuning hints and are passed
 through the HDF5 library to the MPI IO library.
\end_layout

\begin_layout Standard
\align center

\series bold
C
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{minted}[bgcolor=bg]{c}     
\end_layout

\begin_layout Plain Layout

    int cgp_pio_mode(CGNS_ENUMT(PIOmode_t) mode, MPI_Info info)
\end_layout

\begin_layout Plain Layout


\backslash
end{minted} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center

\series bold
Fortran
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{minted}[bgcolor=bg]{fortran}     
\end_layout

\begin_layout Plain Layout

     CALL cgp_pio_mode_f(mode, comm_info, ierr)
\end_layout

\begin_layout Plain Layout

        INTEGER(KIND(CGP_COLLECTIVE)) :: mode ! Use parameters CGP_INDEPENDENT
 or CGP_COLLECTIVE
\end_layout

\begin_layout Plain Layout

        INTEGER :: comm_info
\end_layout

\begin_layout Plain Layout

        INTEGER :: ierr
\end_layout

\begin_layout Plain Layout


\backslash
end{minted} 
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Functions for parallel reading and writing multi-component datasets using
 a single call was introduced.
 The new APIs use new capabilities introduced in version 1.8.* (currently
 not released as of 10.13.2014) of the HDF5 library.
 The new APIs pack multiple datasets into a single buffer and the underlining
 MPI IO completes the IO request using just one call.
 The availability of the new functions in the HDF5 library is checked at
 compile time.
 The current limitation (due to MPI) is that the size of the datasets must
 be less than 2GB.
\end_layout

\begin_layout Standard
\align center

\series bold
C
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{minted}[bgcolor=bg]{c}
\end_layout

\begin_layout Plain Layout

int cgp_coord_multi_read_data(int fn, int B, int Z, int *C, 
\end_layout

\begin_layout Plain Layout

                              const cgsize_t *rmin, const cgsize_t *rmax,
\end_layout

\begin_layout Plain Layout

                              void *coordsX,  void *coordsY,  void *coordsZ);
\end_layout

\begin_layout Plain Layout


\backslash
end{minted}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{minted}[bgcolor=bg]{c}  
\end_layout

\begin_layout Plain Layout

int cgp_coord_multi_write_data(int fn, int B, int Z, int *C, 
\end_layout

\begin_layout Plain Layout

                               const cgsize_t *rmin, const cgsize_t *rmax,
\end_layout

\begin_layout Plain Layout

                               const void *coordsX, const void *coordsY,
 const void *coordsZ);
\end_layout

\begin_layout Plain Layout


\backslash
end{minted}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{minted}[bgcolor=bg]{c}
\end_layout

\begin_layout Plain Layout

 int cgp_field_multi_read_data(int fn, int B, int Z, int S, int *F,
\end_layout

\begin_layout Plain Layout

                               const cgsize_t *rmin, const cgsize_t *rmax,
\end_layout

\begin_layout Plain Layout

                               int nsets, ...);
\end_layout

\begin_layout Plain Layout

/* ...
 nsets of variable arguments, *solution_array, corresponding to the order
 given by F */
\end_layout

\begin_layout Plain Layout


\backslash
end{minted}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{minted}[bgcolor=bg]{c}
\end_layout

\begin_layout Plain Layout

int cgp_field_multi_write_data(int fn, int B, int Z, int S, int *F,
\end_layout

\begin_layout Plain Layout

                               const cgsize_t *rmin, const cgsize_t *rmax,
\end_layout

\begin_layout Plain Layout

                               int nsets, ...);
\end_layout

\begin_layout Plain Layout

/* ...
 nsets of variable arguments, *solution_array, corresponding to the order
 given by F */
\end_layout

\begin_layout Plain Layout


\backslash
end{minted}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{minted}[bgcolor=bg]{c}
\end_layout

\begin_layout Plain Layout

int cgp_array_multi_write_data(int fn, int *A, const cgsize_t *rmin, const
 cgsize_t *rmax,
\end_layout

\begin_layout Plain Layout

                               int nsets, ...);
\end_layout

\begin_layout Plain Layout

/* ...
 nsets of variable arguments, *field_array, corresponding to the order given
 by F */
\end_layout

\begin_layout Plain Layout


\backslash
end{minted}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{minted}[bgcolor=bg]{c}
\end_layout

\begin_layout Plain Layout

int cgp_array_multi_read_data(int fn, int *A, const cgsize_t *rmin,const
 cgsize_t *rmax,
\end_layout

\begin_layout Plain Layout

                              int nsets, ...);
\end_layout

\begin_layout Plain Layout

/* ...
 nsets of variable arguments, *field_array, corresponding to the order given
 by F */
\end_layout

\begin_layout Plain Layout


\backslash
end{minted}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center

\series bold
Fortran
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{minted}[bgcolor=bg]{fortran}
\end_layout

\begin_layout Plain Layout

CALL cgp_coord_multi_read_data_f(fn, B, Z, C, rmin, rmax, coordsX, coordsY,
 coordsZ, ier)
\end_layout

\begin_layout Plain Layout

   INTEGER :: fn
\end_layout

\begin_layout Plain Layout

   INTEGER :: B
\end_layout

\begin_layout Plain Layout

   INTEGER :: Z
\end_layout

\begin_layout Plain Layout

   INTEGER :: C
\end_layout

\begin_layout Plain Layout

   INTEGER(CG_SIZE_T) :: rmin
\end_layout

\begin_layout Plain Layout

   INTEGER(CG_SIZE_T) :: rmax
\end_layout

\begin_layout Plain Layout

   REAL :: coordsX, coordsY, coordsZ
\end_layout

\begin_layout Plain Layout

   INTEGER :: ier
\end_layout

\begin_layout Plain Layout


\backslash
end{minted}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{minted}[bgcolor=bg]{fortran}
\end_layout

\begin_layout Plain Layout

CALL cgp_coord_multi_write_data_f(fn, B, Z, C, rmin, rmax, coordsX, coordsY,
 coordsZ, ier)
\end_layout

\begin_layout Plain Layout

   INTEGER :: fn
\end_layout

\begin_layout Plain Layout

   INTEGER :: B
\end_layout

\begin_layout Plain Layout

   INTEGER :: Z
\end_layout

\begin_layout Plain Layout

   INTEGER :: C
\end_layout

\begin_layout Plain Layout

   INTEGER(CG_SIZE_T) :: rmin
\end_layout

\begin_layout Plain Layout

   INTEGER(CG_SIZE_T) :: rmax
\end_layout

\begin_layout Plain Layout

   REAL :: coordsX, coordsY, coordsZ
\end_layout

\begin_layout Plain Layout

   INTEGER :: ier
\end_layout

\begin_layout Plain Layout


\backslash
end{minted}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{minted}[bgcolor=bg]{fortran}
\end_layout

\begin_layout Plain Layout

CALL cgp_field_multi_write_data_f(fn, B, Z, S, F, rmin, rmax, ier, nsets,
 ...)
\end_layout

\begin_layout Plain Layout

   INTEGER :: fn
\end_layout

\begin_layout Plain Layout

   INTEGER :: B
\end_layout

\begin_layout Plain Layout

   INTEGER :: Z
\end_layout

\begin_layout Plain Layout

   INTEGER :: C
\end_layout

\begin_layout Plain Layout

   INTEGER(CG_SIZE_T) :: rmin
\end_layout

\begin_layout Plain Layout

   INTEGER(CG_SIZE_T) :: rmax
\end_layout

\begin_layout Plain Layout

   INTEGER :: ier
\end_layout

\begin_layout Plain Layout

   INTEGER :: nsets
\end_layout

\begin_layout Plain Layout

   ...
 REAL, DIMENSION(*) :: field_array ! entered nsets times 
\end_layout

\begin_layout Plain Layout


\backslash
end{minted}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{minted}[bgcolor=bg]{fortran}
\end_layout

\begin_layout Plain Layout

CALL cgp_field_multi_read_data_f(fn, B, Z, S, F, rmin, rmax, ier, nsets,
 ...)
\end_layout

\begin_layout Plain Layout

   INTEGER :: fn
\end_layout

\begin_layout Plain Layout

   INTEGER :: B
\end_layout

\begin_layout Plain Layout

   INTEGER :: Z
\end_layout

\begin_layout Plain Layout

   INTEGER :: C
\end_layout

\begin_layout Plain Layout

   INTEGER(CG_SIZE_T) :: rmin
\end_layout

\begin_layout Plain Layout

   INTEGER(CG_SIZE_T) :: rmax
\end_layout

\begin_layout Plain Layout

   INTEGER :: ier
\end_layout

\begin_layout Plain Layout

   INTEGER :: nsets
\end_layout

\begin_layout Plain Layout

   ...
 REAL, DIMENSION(*) :: field_array ! entered nsets times 
\end_layout

\begin_layout Plain Layout


\backslash
end{minted}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{minted}[bgcolor=bg]{fortran}
\end_layout

\begin_layout Plain Layout

CALL cgp_array_multi_write_data_f(fn, B, Z, S, F, rmin, rmax, ier, nsets,
 ...)
\end_layout

\begin_layout Plain Layout

   INTEGER :: fn
\end_layout

\begin_layout Plain Layout

   INTEGER :: B
\end_layout

\begin_layout Plain Layout

   INTEGER :: Z
\end_layout

\begin_layout Plain Layout

   INTEGER :: C
\end_layout

\begin_layout Plain Layout

   INTEGER(CG_SIZE_T) :: rmin
\end_layout

\begin_layout Plain Layout

   INTEGER(CG_SIZE_T) :: rmax
\end_layout

\begin_layout Plain Layout

   INTEGER :: ier
\end_layout

\begin_layout Plain Layout

   INTEGER :: nsets
\end_layout

\begin_layout Plain Layout

   ...
 REAL, DIMENSION(*) :: data_array ! entered nsets times 
\end_layout

\begin_layout Plain Layout


\backslash
end{minted}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{minted}[bgcolor=bg]{fortran}
\end_layout

\begin_layout Plain Layout

CALL cgp_array_multi_read_data_f(fn, B, Z, S, F, rmin, rmax, ier, nsets,
 ...)
\end_layout

\begin_layout Plain Layout

   INTEGER :: fn
\end_layout

\begin_layout Plain Layout

   INTEGER :: B
\end_layout

\begin_layout Plain Layout

   INTEGER :: Z
\end_layout

\begin_layout Plain Layout

   INTEGER :: C
\end_layout

\begin_layout Plain Layout

   INTEGER(CG_SIZE_T) :: rmin
\end_layout

\begin_layout Plain Layout

   INTEGER(CG_SIZE_T) :: rmax
\end_layout

\begin_layout Plain Layout

   INTEGER :: ier
\end_layout

\begin_layout Plain Layout

   INTEGER :: nsets
\end_layout

\begin_layout Plain Layout

   ...
 REAL, DIMENSION(*) :: data_array ! entered nsets times 
\end_layout

\begin_layout Plain Layout


\backslash
end{minted}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
New C changes
\end_layout

\begin_layout Itemize
A new example benchmark program, benchmark_hdf5.c was added to ptests.
\end_layout

\begin_layout Subsection
New Fortran changes
\end_layout

\begin_layout Standard
All users are 
\series bold
\color black
strongly
\series default
\color inherit
 encouraged to use a Fortran 2003 standard compliant compiler.
 Using a Fortran 2003 compiler guarantees interoperability with the C APIs
 via the ISO_C_BINDING module.
 Many changes where added to the CGNS library in order to take full advantage
 of the interoperability offered by the ISO_C_BINDING module.
 
\end_layout

\begin_layout Enumerate
Configure was changed to check if the Fortran compiler is Fortran 2003 compliant.
 If it is then the features of ISO_C_BINDING will be used.
 
\end_layout

\begin_layout Enumerate
The predefined CGNS constant parameters data types were changed from INTEGER
 to ENUM, BIND(C) for better C interoperability.
 The users should use the predefined constants whenever possible and not
 the numerical value represented by the constants.
\end_layout

\begin_layout Enumerate

\shape italic
\color blue
INCLUDE 
\begin_inset Quotes eld
\end_inset

cgslib_h
\begin_inset Quotes erd
\end_inset


\shape default
 was changed in favore of using a module, USE CGNS.
\end_layout

\begin_deeper
\begin_layout Enumerate
This allows defining a KIND type for integers instead of the current way
 of using the preprocessor dependent 
\shape italic
cgsize_t
\shape default
.
\end_layout

\begin_layout Enumerate
Backward compatibility might be added before the merge to the trunk.
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset CommandInset label
LatexCommand label
name "enu:int64"

\end_inset

The user should be sure to declare the arguments declared 
\shape italic
int
\shape default
 in the C APIs as INTEGER in Fortran.
 The ONLY fortran arguments declared as type 
\shape italic
cgsize_t
\shape default
 should be the arguments also declared
\shape italic
 cgsize_t
\shape default
 in the C APIs.
 This is very important when building with option 
\shape italic
--enable-64bit
\shape default
.
\end_layout

\begin_layout Enumerate
Assuming the rules in step 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:int64"

\end_inset

 were followed, users should not need to use parameter CG_BUILD_64BIT since
 Fortran's 
\shape italic
cgsize_t
\shape default
 is now guaranteed to match C's 
\shape italic
cgsize_t
\shape default
.
 
\end_layout

\begin_layout Enumerate

\color red
Fortran programs defining CGNS data types with a default INTEGER size of
 8 bytes are not currently compatible
\color inherit
.
 This is independent of whether or not 
\shape italic
--enable-64bit
\shape default
 is being used.
 For clarification, using 
\shape italic
--enable-64bit
\shape default
 allows for data types (i.e.
 those declared as 
\shape italic
cgsize_t
\shape default
) to be able to store values which are too large to be stored as 4 byte
 integers (i.e.
 numbers greater then 2,147,483,647).
 It is not necessary, or advisable, to have CGNS INTEGER types (types declared
 
\shape italic
int
\shape default
 in C) to be 8 bytes; the variables declared as 
\shape italic
cgsize_t
\shape default
 will automatically handle data types that can not be stored as 4 byte integers
 when 
\shape italic
--enable-64bit
\shape default
 is being used.
 
\end_layout

\begin_deeper
\begin_layout Enumerate
CGNS developer's note: A new C data type, cgint_f, was introduced to be
 interpretable with the C type 
\shape italic
int
\shape default
.
 In order to allow for default 8 byte integers in Fortran: (1) The C API
 wrappers in cg_ftoc.c need to be changed from 
\shape italic
cgsize_t
\shape default
 to 
\shape italic
cgint_f
\shape default
 everywhere the C argument is declared as an 
\shape italic
int
\shape default
 in C, (2) configure needs to detect what size the default integer is in
 Fortran and find the corresponding size in C in order to set the correct
 size of cgint_f.
\end_layout

\end_deeper
\begin_layout Enumerate
Two new benchmarking programs were introduced in directory ptests:
\end_layout

\begin_deeper
\begin_layout Enumerate
benchmarking_hdf5_f90.F90 uses the conventional Fortran wrappers.
\end_layout

\begin_layout Enumerate
benchmarking_hdf5_f03.F90 calls the C APIs directly, no Fortran wrappers
 are used.
\end_layout

\end_deeper
\begin_layout Section
Parallel installation instructions
\end_layout

\begin_layout Standard
Two parallel files systems were investigated: GPFS (mira, Argonne National
 Laboratory) and Lustre (Pleiades NASA).
 The following descriptions were performed on these systems, but the overall
 procedure should be similar on different machines of the same type.
 Example build scripts for these systems can be found in src/sampleScripts
 of the CGNS source code.
 They include scripts for building zlib, hdf5 (assuming the user does not
 already have them install system wide) and a script for building CGNS.
 All the scripts use autotools; 
\color red
cmake remains untested
\color inherit
.
 The next few examples assume all the needed packages are in ${HOME}/packages
 and all the build scripts are placed in ${HOME}/packages.
 This information can also be found in the README.txt in the scripts directory.
\end_layout

\begin_layout Subsection
Building on IBM Blue Gene (GPFS)
\end_layout

\begin_layout Enumerate
Building zlib from source: Download and extract the zlib source: http://www.zlib.n
et/
\end_layout

\begin_deeper
\begin_layout Enumerate
cd into the top level zlib source directory.
 
\end_layout

\begin_layout Enumerate
modify and run the script: ../build_zlib
\end_layout

\end_deeper
\begin_layout Enumerate
Building hdf5 from source
\end_layout

\begin_deeper
\begin_layout Enumerate
From the top level of the hdf5 library, change the ${HOME}/packages to where
 zlib was installed in STEP 1.
 
\end_layout

\begin_layout Enumerate
../build_hdf5 --without-pthread --disable-shared --enable-parallel --enable-produc
tion 
\backslash
 --enable-fortran --enable-fortran2003 
\backslash
 --disable-stream-vfd --disable-direct-vfd 
\backslash
 --with-zlib=${HOME}/packages/zlib-1.2.8/lib --prefix=${HOME}/packages/phdf5-trunk
\end_layout

\begin_layout Standard
where prefix is set for where the hdf5 library will get installed.
 There should be no need to modify in the script.
\end_layout

\end_deeper
\begin_layout Enumerate
Building cgns from source:
\end_layout

\begin_deeper
\begin_layout Enumerate
cd into the cgns/src directory 
\end_layout

\begin_layout Enumerate
modify and run: <pathto>/build_cgns 
\end_layout

\begin_layout Enumerate
make
\end_layout

\begin_layout Enumerate
To make the tests: cd ptests; make;make tests
\end_layout

\end_deeper
\begin_layout Enumerate
IMPORTANT PARAMETERS FOR GOOD PERFORMANCE
\end_layout

\begin_deeper
\begin_layout Enumerate
The environment variable BGLOCKLESSMPIO_F_TYPE=0x47504653 should be set.
 For example, this can be set using qsub --env BGLOCKLESSMPIO_F_TYPE=0x47504653
\end_layout

\end_deeper
\begin_layout Subsection
Building on SGI (Lustre)
\end_layout

\begin_layout Enumerate
Building zlib from source: Download and extract the zlib source: http://www.zlib.n
et/
\end_layout

\begin_deeper
\begin_layout Enumerate
cd into the top level zlib source directory.
 
\end_layout

\begin_layout Enumerate
modify and run the script: ../build_zlib
\end_layout

\end_deeper
\begin_layout Enumerate
Building hdf5 from source
\end_layout

\begin_deeper
\begin_layout Enumerate
From the top level of the hdf5 library, change the ${HOME}/packages to where
 zlib was installed in STEP 1.
 
\end_layout

\begin_layout Enumerate
../build_hdf5
\end_layout

\end_deeper
\begin_layout Enumerate
Building cgns from source:
\end_layout

\begin_deeper
\begin_layout Enumerate
cd into the cgns/src directory 
\end_layout

\begin_layout Enumerate
modify and run: <pathto>/build_cgns 
\end_layout

\begin_layout Enumerate
make
\end_layout

\begin_layout Enumerate
To make the tests: cd ptests; make;make tests
\end_layout

\end_deeper
\begin_layout Enumerate
IMPORTANT PARAMETERS FOR GOOD PERFORMANCE
\end_layout

\begin_deeper
\begin_layout Enumerate
The Lustre parameters have not been fully tested.
\end_layout

\begin_layout Enumerate
On Pleiades, lfs setstripe -c 64 -s 0 /nobackupp8/<dir>, has shown good
 performance.
\end_layout

\end_deeper
\end_body
\end_document
